/**
 * This file was auto-generated by the Titanium Module SDK helper for Android
 * Appcelerator Titanium Mobile
 * Copyright (c) 2009-2013 by Appcelerator, Inc. All Rights Reserved.
 * Licensed under the terms of the Apache Public License
 * Please see the LICENSE included with this distribution for details.
 * 
 * 
 * the solution for ImageFactoryModule was coming from this ticket
 * https://jira.appcelerator.org/browse/TIMOB-3427
 * https://github.com/freshheads/fh.imagefactory
 * 
 * This code was taken straight from this Jira ticket: https://jira.appcelerator.org/browse/TIMOB-3887
 *
 */
package com.alcoapps.imageutility;

import java.util.HashMap;
import java.util.Map;
import java.lang.Math;
 
import org.appcelerator.kroll.KrollDict;
import org.appcelerator.kroll.KrollModule;
import org.appcelerator.kroll.annotations.Kroll;
 
import org.appcelerator.titanium.TiApplication;
import org.appcelerator.kroll.common.Log;
import org.appcelerator.kroll.common.TiConfig;
import org.appcelerator.kroll.common.Log;
import org.appcelerator.titanium.util.TiConvert;
 
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
 
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Matrix;
import android.media.ExifInterface;
import org.appcelerator.titanium.TiApplication;
import org.appcelerator.kroll.common.Log;

@Kroll.module(name="Imageutility", id="com.alcoapps.imageutility")
public class ImageutilityModule extends KrollModule
{

	// Standard Debugging variables
	private static final String TAG = "com.company.utils";
	 
    @Kroll.constant public static final String TAG_ORIENTATION = ExifInterface.TAG_ORIENTATION;
    @Kroll.constant public static final int ORIENTATION_ROTATE_180 = ExifInterface.ORIENTATION_ROTATE_180;
    @Kroll.constant public static final int ORIENTATION_ROTATE_270 = ExifInterface.ORIENTATION_ROTATE_270;
    @Kroll.constant public static final int ORIENTATION_ROTATE_90 = ExifInterface.ORIENTATION_ROTATE_90;
 
	
	public ImageutilityModule()
	{
		super();
	}

	@Kroll.onAppCreate
    public static void onAppCreate(TiApplication app) {
    }
 
    // Methods
    /**
     * Auto rotate and resize to the desired maximum size keeping aspect
     *
     * @param filename
     * @param size
     * @param quality
     * @return
     */
    @Kroll.method
    public Boolean rotateResizeImage(String filename, int size, int quality, float zoom)
    {
        File imageFile = null;
        FileInputStream fileInputStream = null;
        FileInputStream fileInputStream2 = null;
        FileOutputStream fileOutputStream = null;
        Bitmap scaledBitmap = null;
        Bitmap resizedBitmap = null;
        Bitmap zoomedBitmap = null;
        try
        {
            // Determine the orientation
            int rotation = getRotation(filename);
 
            // Read the file path into a File
            imageFile = new File(convertPath(filename));
 
            // Decode once to determine size
            BitmapFactory.Options opts = new BitmapFactory.Options();
            opts.inJustDecodeBounds = true;
            fileInputStream = new FileInputStream(imageFile);
            BitmapFactory.decodeStream(fileInputStream, null, opts);
            Log.i(TAG, "Original image size: " + opts.outWidth + "x" + opts.outHeight);
 
            // Determine intermediate size based on zoom
            int intermediateSize = (int) (size / zoom);

            Log.i(TAG, "Intermediate target size: " + intermediateSize);
            
            // Determine scaling based on size
            int smallestDimension = Math.min(opts.outWidth, opts.outHeight);
            int sample = 1;
            while (smallestDimension / sample / 2 >= intermediateSize) {
                sample *= 2;
            }
            opts = new BitmapFactory.Options();
            opts.inSampleSize = sample;
            Log.i(TAG, "Sample size: " + sample);
 
            // Decode with scaling applied to save a huge amount of memory
            fileInputStream2 = new FileInputStream(imageFile);
            scaledBitmap = BitmapFactory.decodeStream(fileInputStream2, null, opts);
            Log.i(TAG, "Sampled image size: " + opts.outWidth + "x" + opts.outHeight);
 
            // Create the appropriate Matrix to resize and rotate then create Bitmap
            float scale = (float)intermediateSize / (float)(opts.outWidth > opts.outHeight ? opts.outWidth : opts.outHeight);
            Matrix matrix = new Matrix();
            matrix.postRotate(rotation);
            matrix.postScale(scale, scale);
            
            // Square that madness
            int intermediateCropSize = 0;
            int x = 0;
            int y = 0;
            
            if (opts.outWidth >= opts.outHeight){
	            intermediateCropSize = opts.outHeight;
	            x = (opts.outWidth - intermediateCropSize)/2;
	            y = 0;
            } else {
	            intermediateCropSize = opts.outWidth;
	            x = 0;
	            y = (opts.outHeight - intermediateCropSize)/2;
            }
            
            Log.i(TAG, "Squaring coordinates: " + x + ", " + y);
            
            resizedBitmap = Bitmap.createBitmap(scaledBitmap, x, y, intermediateCropSize, intermediateCropSize, matrix, true);
            Log.i(TAG, "Resized size: " + resizedBitmap.getWidth() + "x" + resizedBitmap.getHeight());
 
            // Scale that madness
            if (zoom < 1) {
            	int cropOffset = (resizedBitmap.getWidth() - size)/2;

                Log.i(TAG, "Cropping offset: " + cropOffset);
                
            	zoomedBitmap = Bitmap.createBitmap(resizedBitmap, cropOffset, cropOffset, size, size);
            	Log.i(TAG, "Cropped size: " + zoomedBitmap.getWidth() + "x" + zoomedBitmap.getHeight());
            } else {
            	zoomedBitmap = resizedBitmap;
            }
            
            // Recreate file
            imageFile.delete();
            imageFile.createNewFile();

            // Copy rotated, resized image to new file
            fileOutputStream = new FileOutputStream(imageFile);
            
            // Compress
            zoomedBitmap.compress(Bitmap.CompressFormat.JPEG, quality, fileOutputStream);
            Log.i(TAG, "Compressed image to " + quality + " quality");

            fileOutputStream.flush();
            Log.i(TAG, "Saved image to file");
 
            return true;
        }
        catch (Exception e)
        {
            Log.e(TAG, "ERROR: " + e.toString());
            return false;
        }
        finally {
            if(imageFile != null) {
                imageFile = null;
            }
            if(fileInputStream != null) {
                try {
                    fileInputStream.close();
                } catch (IOException e) {
                }
                fileInputStream = null;
            }
            if(fileInputStream2 != null) {
                try {
                    fileInputStream2.close();
                } catch (IOException e) {
                }
                fileInputStream2 = null;
            }
            if(fileOutputStream != null) {
                try {
                    fileOutputStream.close();
                } catch (IOException e) {
                }
                fileOutputStream = null;
            }
            if(scaledBitmap != null) {
                scaledBitmap.recycle();
                scaledBitmap = null;
            }
            if(resizedBitmap != null) {
                resizedBitmap.recycle();
                resizedBitmap = null;
            }
            if(zoomedBitmap != null) {
            	zoomedBitmap.recycle();
            	zoomedBitmap = null;
            }
        }
    }
 
    private Integer getRotation(String filename) {
        int orientation = TiConvert.toInt(getExifTag(filename, TAG_ORIENTATION));
        Log.i(TAG, "Detected orientation: " + orientation);
        int rotation = 0;
        switch (orientation)
        {
            case ORIENTATION_ROTATE_90:
                rotation = 90;
                break;
 
            case ORIENTATION_ROTATE_180:
                rotation = 180;
                break;
 
            case ORIENTATION_ROTATE_270:
                rotation = 270;
                break;
        }
        Log.i(TAG, "Determined rotation: " + rotation);
        return rotation;
    }
 
    private String getExifTag(String filename, String tag)
    {
        String property = "";
        ExifInterface exif;
        filename = convertPath(filename);
        try {
            //Log.i(TAG, "Read Exif tag: " + tag + ", from file: " + filename);
            exif = new ExifInterface(filename);
            property = exif.getAttribute(tag);
            //Log.i(TAG, "Exif tag value: " + property);
        }
        catch (IOException e)
        {
            property = "";
            Log.e(TAG, "IO Exception occured, file probably does not exist.");
        }
        return property;
    }
 
    private String convertPath(String path)
    {
        //Log.i(TAG, "Open FileInputStream for path: " + path);
        if (path.startsWith("file://") || path.startsWith("content://") || path.startsWith("appdata://") || path.startsWith("appdata-private://"))
        {
            path = path.replaceAll("file://", "");
            path = path.replaceAll("content://", "");
            path = path.replaceAll("appdata:///?", "/mnt/sdcard/" + TiApplication.getInstance().getPackageName() + "/");
            path = path.replaceAll("appdata-private:///?", "/data/data/" + TiApplication.getInstance().getPackageName() + "/app_appdata/");
            //Log.i(TAG, "Converted path to: " + path);
        }
        return path;
    }
}
